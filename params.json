{"name":"Messageloop","tagline":"","body":"MessageLoop\r\n===========\r\n\r\n\r\n\r\n### 功能要求\r\n* 1. 用于多线程间进行单向的消息传递，可以做到有多个发送线程向一个接收线程发送消息。\r\n* 2. 该模块能让消息的接收者，发送者（线程）能够简单方便地使用\r\n* 3. 接收者能够及时地收到消息，并立即对该消息做出反应（不需要把反应结果告诉发送者）\r\n* 4. 该模块不能过多地占用cpu资源\r\n* 5. 该模块能在Win，Unix/Linux平台下编译使用\r\n* 6. 线程安全\r\n* 7. 接收线程里可以有多个接收者\r\n\r\n### 消息的内容应该有如下的项目\r\n* 1. 消息识别码，它是一种接收者和发送者都共识的代码，发送者通过这个代码可以让接收者明白它的意图\r\n* 2. 欲发送的消息，包含下面两种消息：\r\n*     2.1 字符串\r\n*     2.2 自定义的数据结构 基本上接收者通过该消息的识别码可以明白该数据结构的数据类型\r\n\r\n\r\n### 实现原理\r\n使用socket和I/O多路复用select来实现，因为socket是跨平台，且在等待消息的时候不占用cpu资源\r\n* 1.用select的fdset来模拟一个消息队列\r\n* 2.接收者创建一个服务端socket\r\n* 3.把连接到这个服务端socket的发送端socket放入到fdset中\r\n* 4.接收者可以使用select来监控这个fdset\r\n* 5.fdset中一旦有可读项，则找出对应的发送端socket\r\n* 6.根据这个发送端的socket中找到相对应的Message\r\n* 7.让接收者处理这个Message。\r\n\r\n### 基于上述的原理，可以抽出如下的class：\r\n* 1. 接收者类 Handler\r\n    因为在接收线程里可以有多个接收者，所以必须把接收者定义成一个类，\r\n    该类的功能就是对收到的消息进行反应\r\n* 2. 消息类 Message\r\n    存储消息内容，并把消息发送给消息循环类\r\n* 3. 消息循环类 Looper\r\n    监听消息队列，一旦有消息来临时，就找到该消息的发送目标（Handler），然后送给他。\r\n    并把该消息从消息队列中删除掉。\r\n* 4. 消息队列类\r\n    就是存放所有未处理消息的队列\r\n\r\n上面内容参照了Android的Handler+Looper的机制\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}